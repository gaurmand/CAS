#include <concepts>

#include "quorem.h"

namespace
{

template<typename T>
concept Addition = requires(T a, T b)
{
   {a + b} -> std::same_as<T>;
};

template<typename T>
concept AdditiveIdentity = requires
{
   {T::zero()} -> std::same_as<T>;
};

template<typename T>
concept AdditiveInverses = requires(T a, T b)
{
   {-a} -> std::same_as<T>;
   {a - b} -> std::same_as<T>;
};

template<typename T>
concept Multiplication = requires(T a, T b)
{
   {a * b} -> std::same_as<T>;
};

template<typename T>
concept MultiplicativeIdentity = requires
{
   {T::unity()} -> std::same_as<T>;
};

template<typename T>
concept MultiplicativeInverse = requires(T a, T b)
{
   {~a} -> std::same_as<T>;
   {a / b} -> std::same_as<T>;   // Return q such that a = b * q + 0 (i.e. q = a * ~b)
};

template<typename T>
concept EuclideanDivision = requires(T a, T b)
{
   {a / b} -> std::same_as<T>;   // Return q such that a = b * q + r where 0 < r < norm(b)
   {a % b} -> std::same_as<T>;   // Return r such that a = b * q + r where 0 < r < norm(b)
   {a.quorem(b)} -> std::same_as<CAS::QuoremResult<T>>;
};

}

namespace CAS
{

template<typename T>
concept Group = Addition<T> && AdditiveIdentity<T> && AdditiveInverses<T>;

template<typename T>
concept Ring = Group<T> && Multiplication<T> && MultiplicativeIdentity<T>;

// IntegralDomain = Ring where no element is a zero divisor
// IntegrallyClosedDomain = ???
// GCDDomain = IntegralDomain where every two elements have a GCD
// UniqueFactorizationDomain = GCDDomain where every element has a irreducible factorization unique up to multiplication by a unit
// PrincipleIdealDomain = UniqueFactorizationDomain where every ideal is principal (i.e. every ideal can be generated by a single element)

template<typename T>
concept EuclideanDomain = Ring<T> && EuclideanDivision<T>;

template<typename T>
concept Field = EuclideanDomain<T> && MultiplicativeInverse<T>;

// AlgebraicallyClosedField = Field where every polynomial in F[x] has a root in F

} // namespace CAS
